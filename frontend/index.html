<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Behavioral Pattern Discovery</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

header {
    background: white;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

header h1 {
    margin-bottom: 20px;
    color: #2c3e50;
}

.status-bar {
    display: flex;
    gap: 30px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 6px;
}

.status-item {
    display: flex;
    align-items: center;
    gap: 10px;
}

.status-item .label {
    font-weight: 600;
    color: #666;
}

.status-value {
    font-size: 16px;
}

.card {
    background: white;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.card h2 {
    margin-bottom: 25px;
    color: #2c3e50;
    border-bottom: 2px solid #3498db;
    padding-bottom: 10px;
}

.step {
    margin-bottom: 30px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 6px;
}

.step h3 {
    margin-bottom: 15px;
    color: #34495e;
}

.description {
    color: #7f8c8d;
    font-size: 14px;
    margin-bottom: 15px;
}

.controls {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    flex-wrap: wrap;
    align-items: center;
}

.separator {
    color: #95a5a6;
    font-size: 18px;
    font-weight: 300;
    padding: 0 5px;
}

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.btn-primary {
    background: #3498db;
    color: white;
}

.btn-primary:hover:not(:disabled) {
    background: #2980b9;
}

.btn-secondary {
    background: #95a5a6;
    color: white;
}

.btn-secondary:hover:not(:disabled) {
    background: #7f8c8d;
}

.btn-danger {
    background: #e74c3c;
    color: white;
}

.btn-danger:hover:not(:disabled) {
    background: #c0392b;
}

input, .select {
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    font-size: 14px;
}

input[type="number"] {
    width: 150px;
}

input[type="text"] {
    width: 150px;
}

.select {
    min-width: 300px;
    background: white;
}

.status-message {
    margin-top: 10px;
    padding: 10px;
    border-radius: 4px;
    font-size: 14px;
}

.status-message.success {
    background: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.status-message.error {
    background: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

.status-message.info {
    background: #d1ecf1;
    color: #0c5460;
    border: 1px solid #bee5eb;
}

.report-container, .scores-container {
    margin-top: 20px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 6px;
}

.report-content, .scores-content {
    background: #2c3e50;
    color: #ecf0f1;
    padding: 20px;
    border-radius: 4px;
    overflow-x: auto;
    max-height: 500px;
    overflow-y: auto;
    font-size: 13px;
    line-height: 1.5;
}

.logs-container {
    background: #2c3e50;
    color: #ecf0f1;
    padding: 15px;
    border-radius: 6px;
    height: 400px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    font-size: 12px;
}

.log-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.log-line {
    margin-bottom: 5px;
    padding: 2px 0;
}

.log-error {
    color: #e74c3c;
}

.log-warning {
    color: #f39c12;
}

.log-info {
    color: #3498db;
}

/* Loader Tabs */
.loader-tabs {
    display: flex;
    gap: 0;
    margin-bottom: 15px;
    border-bottom: 2px solid #ddd;
}

.loader-tab {
    padding: 10px 20px;
    border: none;
    background: #f5f5f5;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    color: #666;
    border-radius: 4px 4px 0 0;
    margin-bottom: -2px;
    border: 2px solid transparent;
    border-bottom: none;
    transition: all 0.2s ease;
}

.loader-tab:hover {
    background: #e8e8e8;
    color: #333;
}

.loader-tab.active {
    background: white;
    color: #3498db;
    border-color: #ddd;
    border-bottom-color: white;
}

.tab-content {
    padding-top: 10px;
}

.tab-content:not(.active) {
    display: none;
}

.section {
    margin-bottom: 20px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 6px;
}

.section h3 {
    margin-bottom: 10px;
    color: #34495e;
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Behavioral Pattern Discovery</h1>
        </header>

        <main>
            <!-- Data Collection Section -->
            <section class="card">
                <h2>Data Collection</h2>

                <div class="section">
                    <h3>1. Fetch Data</h3>

                    <!-- Tabs -->
                    <div class="loader-tabs">
                        <button class="loader-tab active" data-tab="mongodb">MongoDB</button>
                        <button class="loader-tab" data-tab="ndjson">NDJSON</button>
                    </div>

                    <!-- MongoDB Tab Content -->
                    <div id="tab-mongodb" class="tab-content active">
                        <div class="controls">
                            <input type="text" id="mongodb-database" placeholder="Leave empty to use config default (database/collection format)" value="" title="Format: database/collection. Leave empty to use config default. Examples: FamaActivityRaw/all, Aude-production/b27281ee_Slack_activities. Use 'all' to fetch all collections from a database." style="min-width: 600px;">
                            <input type="number" id="mongodb-max-engineers" placeholder="Max engineers (optional)" title="Maximum number of engineers to fetch">
                            <input type="number" id="mongodb-max-activities" placeholder="Max activities/engineer (optional)" title="Maximum activities per engineer">
                        </div>
                        <div class="controls" style="margin-top: 8px;">
                            <label style="display: inline-flex; align-items: center; gap: 4px;">
                                <input type="checkbox" id="mongodb-append" checked>
                                Append to existing
                            </label>
                            <button id="btn-fetch-mongodb" class="btn btn-primary">Fetch MongoDB</button>
                        </div>
                        <div id="mongodb-status" class="status-message"></div>
                    </div>

                    <!-- NDJSON Tab Content -->
                    <div id="tab-ndjson" class="tab-content" style="display: none;">
                        <div class="controls">
                            <input type="text" id="ndjson-path" placeholder="Path to data folder" value="" title="Folder containing adoIdentities.ndjson and *.ndjson.gz data files" style="min-width: 500px;">
                        </div>
                        <div class="controls" style="margin-top: 8px;">
                            <label style="font-size: 0.9em; color: #666;">Date Range (optional):</label>
                            <input type="date" id="ndjson-date-start" title="Start date filter (optional)">
                            <span style="color: #666;">to</span>
                            <input type="date" id="ndjson-date-end" title="End date filter (optional)">
                            <button id="btn-fetch-ndjson" class="btn btn-primary">Load NDJSON</button>
                        </div>
                        <div id="ndjson-status" class="status-message"></div>
                    </div>
                </div>

                <div class="section">
                    <h3>2. Synthetic Profiles</h3>
                    <div class="controls">
                        <input type="number" id="synthetic-copies" placeholder="Copies per profile" value="3" min="1" max="10" style="width: 150px;" title="Number of synthetic copies to generate per template profile">
                        <button id="btn-generate-synthetic" class="btn btn-primary">Generate Synthetic</button>
                        <button id="btn-refresh-synthetic-summary" class="btn btn-secondary">Refresh Summary</button>
                    </div>
                    <div id="synthetic-status" class="status-message"></div>
                    <div id="synthetic-summary-container" style="display: none; margin-top: 10px;">
                        <div style="margin-bottom: 10px;">
                            <strong>Templates:</strong> <span id="synthetic-template-count">0</span> |
                            <strong>Profiles:</strong> <span id="synthetic-profile-count">0</span>
                        </div>
                        <div id="synthetic-details" style="max-height: 150px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 8px; font-size: 0.9em;"></div>
                        <div class="controls" style="margin-top: 10px;">
                            <select id="synthetic-split" style="width: 120px;">
                                <option value="train">Train</option>
                                <option value="validation">Validation</option>
                            </select>
                            <button id="btn-add-synthetic" class="btn btn-primary" disabled>Add to Activities</button>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>3. Engineer Management</h3>
                    <div class="controls">
                        <button id="btn-refresh-engineer-summary" class="btn btn-secondary">Refresh Summary</button>
                    </div>
                    <div id="engineer-summary-status" class="status-message"></div>
                    <div id="engineer-summary-container" style="display: none; margin-top: 10px;">
                        <div style="margin-bottom: 10px;">
                            <strong>Train:</strong> <span id="train-count">0</span> |
                            <strong>Validation:</strong> <span id="validation-count">0</span> |
                            <strong>Bots:</strong> <span id="bot-count">0</span> |
                            <strong>Total:</strong> <span id="total-engineers">0</span>
                        </div>
                        <div style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;">
                            <table id="engineer-summary-table" style="width: 100%; border-collapse: collapse;">
                                <thead style="position: sticky; top: 0; background: #f5f5f5;">
                                    <tr>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">
                                            <input type="checkbox" id="select-all-engineers">
                                        </th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd; cursor: pointer; user-select: none;" data-sort="engineer_id">Engineer ID <span id="sort-indicator-engineer_id"></span></th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd; cursor: pointer; user-select: none;" data-sort="activity_count">Activities <span id="sort-indicator-activity_count"></span></th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd; cursor: pointer; user-select: none;" data-sort="split">Split <span id="sort-indicator-split"></span></th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd; cursor: pointer; user-select: none;" data-sort="sources">Sources <span id="sort-indicator-sources"></span></th>
                                        <th style="padding: 8px; text-align: center; border-bottom: 2px solid #ddd; cursor: pointer; user-select: none;" data-sort="is_bot">Bot <span id="sort-indicator-is_bot"></span></th>
                                        <th style="padding: 8px; text-align: center; border-bottom: 2px solid #ddd; cursor: pointer; user-select: none;" data-sort="is_internal">Internal <span id="sort-indicator-is_internal"></span></th>
                                        <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd; cursor: pointer; user-select: none;" data-sort="projects">Projects <span id="sort-indicator-projects"></span></th>
                                    </tr>
                                </thead>
                                <tbody id="engineer-summary-body">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>4. Actions</h3>
                    <div class="controls">
                        <button id="btn-set-train" class="btn btn-secondary" disabled>Set Train</button>
                        <button id="btn-set-validation" class="btn btn-secondary" disabled>Set Validation</button>
                        <button id="btn-remove-selected" class="btn btn-danger" disabled>Remove Selected</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <div class="controls">
                            <input type="text" id="merge-target-id" placeholder="Merge target ID" title="Canonical engineer ID to merge into">
                            <button id="btn-merge-engineers" class="btn btn-secondary" disabled>Merge Selected</button>
                        </div>
                    </div>
                    <div id="action-status" class="status-message"></div>
                </div>

                <div class="section">
                    <h3>5. Preprocess</h3>
                    <div class="controls">
                        <input type="number" id="max-activities-per-engineer" placeholder="Max activities/engineer" title="Leave empty to use config value or no limit" style="width: 180px;">
                        <button id="btn-preprocess" class="btn btn-primary" disabled>Preprocess Data</button>
                        <button id="btn-normalization" class="btn btn-secondary" disabled>Apply Normalization</button>
                    </div>
                    <div id="preprocess-status" class="status-message"></div>
                </div>
            </section>

            <!-- Training Section -->
            <section class="card">
                <h2>Training</h2>

                <div class="section">
                    <h3>1. Train VAE Model</h3>
                    <div class="controls">
                        <button id="btn-train-vae" class="btn btn-primary" disabled>Train VAE</button>
                        <button id="btn-train-from-existing" class="btn btn-secondary" disabled>Train From Existing VAE</button>
                        <button id="btn-stop-training" class="btn btn-danger" style="display: none;">Stop Training</button>
                    </div>
                    <div id="existing-model-input" style="display: none; margin-top: 8px;">
                        <input type="text" id="existing-model-path" placeholder="Path to existing VAE checkpoint (e.g., /path/to/vae_checkpoint.pt)" style="width: 400px; padding: 6px;">
                        <button id="btn-start-from-existing" class="btn btn-primary">Start Training</button>
                        <button id="btn-cancel-from-existing" class="btn btn-secondary">Cancel</button>
                    </div>
                    <div id="train-status" class="status-message"></div>
                </div>
            </section>

            <!-- Pattern Identification Section -->
            <section class="card">
                <h2>Pattern Identification</h2>

                <div class="section">
                    <h3>1. Score & Assign Messages</h3>
                    <p style="color: #666; font-size: 0.9em; margin: 4px 0 8px 0;">Score all messages through VAE and assign representative examples to each pattern.</p>
                    <div class="controls">
                        <button id="btn-batch-score" class="btn btn-primary" disabled>Run Batch Scoring</button>
                    </div>
                    <div id="batch-status" class="status-message"></div>
                </div>

                <div class="section">
                    <h3>2. SHAP Analysis</h3>
                    <p style="color: #666; font-size: 0.9em; margin: 4px 0 8px 0;">Extract hierarchical weights showing how patterns compose.</p>
                    <div class="controls">
                        <button id="btn-shap-analysis" class="btn btn-primary" disabled>Run SHAP Analysis</button>
                    </div>
                    <div id="shap-status" class="status-message"></div>
                </div>

                <div class="section">
                    <h3>3. Pattern Naming</h3>
                    <p style="color: #666; font-size: 0.9em; margin: 4px 0 8px 0;">Use LLM to name patterns based on message examples and hierarchical composition.</p>
                    <div class="controls">
                        <button id="btn-identify" class="btn btn-primary" disabled>Identify Patterns</button>
                    </div>
                    <div id="identify-status" class="status-message"></div>
                </div>

                <div class="section">
                    <h3>4. Population Analysis</h3>
                    <div class="controls">
                        <button id="btn-population-viewer" class="btn btn-secondary" disabled>Open Population Viewer</button>
                    </div>
                </div>
            </section>

            <!-- Evaluation Section -->
            <section class="card">
                <h2>Evaluation</h2>

                <div class="section">
                    <h3>1. Select Engineer</h3>
                    <div class="controls">
                        <select id="engineer-select" class="select" disabled>
                            <option value="">Select an engineer...</option>
                        </select>
                        <button id="btn-refresh-engineers" class="btn btn-secondary" disabled>Refresh List</button>
                    </div>
                </div>

                <div class="section">
                    <h3>2. Score & Report</h3>
                    <div class="controls">
                        <button id="btn-score" class="btn btn-primary" disabled>Score Engineer</button>
                        <button id="btn-report" class="btn btn-primary" disabled>Generate Report</button>
                    </div>
                    <div id="eval-status" class="status-message"></div>
                </div>

                <div class="section">
                    <h3>3. Results</h3>
                    <div class="controls">
                        <button id="btn-view-report" class="btn btn-secondary" disabled>View Report</button>
                        <button id="btn-download-report" class="btn btn-secondary" disabled>Download Report</button>
                    </div>
                    <div id="scores-container" class="scores-container" style="display: none;">
                        <h4>Scores</h4>
                        <pre id="scores-content" class="scores-content"></pre>
                    </div>
                    <div id="report-container" class="report-container" style="display: none;">
                        <h4>Report</h4>
                        <pre id="report-content" class="report-content"></pre>
                    </div>
                </div>
            </section>

            <!-- Logs Section -->
            <section class="card">
                <h2>Logs</h2>
                <div class="log-controls">
                    <button id="btn-refresh-logs" class="btn btn-secondary">Refresh Logs</button>
                    <button id="btn-clear-logs" class="btn btn-secondary">Clear Display</button>
                </div>
                <div id="logs-container" class="logs-container"></div>
            </section>
        </main>
    </div>

    <script>
// API base URL
const API_BASE = window.location.origin;

// State
let currentEngineerId = null;
let statusCheckInterval = null;
let engineerSummaryData = [];  // Store engineer data for sorting
let currentSortColumn = 'activity_count';  // Default sort column
let currentSortDirection = 'desc';  // Default sort direction

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    initializeApp();
    setupEventListeners();
    startStatusPolling();
});

function initializeApp() {
    updateStatus();
    refreshLogs();
}

function setupEventListeners() {
    // Button listeners
    document.getElementById('btn-preprocess').addEventListener('click', preprocessData);
    document.getElementById('btn-normalization').addEventListener('click', applyNormalization);
    document.getElementById('btn-train-vae').addEventListener('click', trainVAE);
    // Pattern identification - new order: batch_score -> shap_analysis -> identify_patterns
    document.getElementById('btn-batch-score').addEventListener('click', batchScore);
    document.getElementById('btn-shap-analysis').addEventListener('click', runSHAPAnalysis);
    document.getElementById('btn-identify').addEventListener('click', identifyPatterns);
    document.getElementById('btn-population-viewer').addEventListener('click', openPopulationViewer);
    document.getElementById('btn-refresh-engineers').addEventListener('click', refreshEngineers);
    document.getElementById('btn-score').addEventListener('click', scoreEngineer);
    document.getElementById('btn-report').addEventListener('click', generateReport);
    document.getElementById('btn-view-report').addEventListener('click', viewReport);
    document.getElementById('btn-refresh-logs').addEventListener('click', refreshLogs);
    document.getElementById('btn-clear-logs').addEventListener('click', clearLogs);
    document.getElementById('btn-download-report').addEventListener('click', downloadReport);
    document.getElementById('engineer-select').addEventListener('change', onEngineerSelected);

    // MongoDB and engineer management listeners
    document.getElementById('btn-fetch-mongodb').addEventListener('click', fetchMongoDB);
    document.getElementById('btn-refresh-engineer-summary').addEventListener('click', refreshEngineerSummary);

    // NDJSON loader listener
    document.getElementById('btn-fetch-ndjson').addEventListener('click', fetchNDJSON);

    // Train from existing VAE listeners
    document.getElementById('btn-train-from-existing').addEventListener('click', showExistingModelInput);
    document.getElementById('btn-start-from-existing').addEventListener('click', trainFromExistingVAE);
    document.getElementById('btn-cancel-from-existing').addEventListener('click', hideExistingModelInput);

    // Stop training button
    document.getElementById('btn-stop-training').addEventListener('click', stopTraining);

    // Tab switching
    document.querySelectorAll('.loader-tab').forEach(tab => {
        tab.addEventListener('click', (e) => switchLoaderTab(e.target.dataset.tab));
    });

    // Synthetic profile listeners
    document.getElementById('btn-generate-synthetic').addEventListener('click', generateSyntheticProfiles);
    document.getElementById('btn-refresh-synthetic-summary').addEventListener('click', refreshSyntheticSummary);
    document.getElementById('btn-add-synthetic').addEventListener('click', addSyntheticToActivities);
    document.getElementById('btn-set-train').addEventListener('click', () => setEngineerSplit('train'));
    document.getElementById('btn-set-validation').addEventListener('click', () => setEngineerSplit('validation'));
    document.getElementById('btn-remove-selected').addEventListener('click', removeSelectedEngineers);
    document.getElementById('btn-merge-engineers').addEventListener('click', mergeSelectedEngineers);
    document.getElementById('select-all-engineers').addEventListener('change', toggleSelectAllEngineers);

    // Sortable table headers
    document.querySelectorAll('#engineer-summary-table th[data-sort]').forEach(th => {
        th.addEventListener('click', () => sortEngineerTable(th.dataset.sort));
    });
}

function startStatusPolling() {
    updateStatus();
    statusCheckInterval = setInterval(updateStatus, 5000); // Every 5 seconds
}

async function updateStatus() {
    try {
        const response = await fetch(`${API_BASE}/api/status`);
        const data = await response.json();

        const status = data.status;
        const canRun = data.can_run;

        // Enable/disable buttons based on file existence
        document.getElementById('btn-preprocess').disabled = !canRun.preprocess;
        document.getElementById('btn-normalization').disabled = !canRun.train_vae;  // Enabled when preprocessed data exists
        document.getElementById('btn-train-vae').disabled = !canRun.train_vae;
        document.getElementById('btn-train-from-existing').disabled = !canRun.train_vae;

        // Pattern identification buttons - NEW dependency chain
        document.getElementById('btn-batch-score').disabled = !canRun.batch_score;
        document.getElementById('btn-shap-analysis').disabled = !canRun.shap_analysis;
        document.getElementById('btn-identify').disabled = !canRun.identify_patterns;
        // Population viewer works with or without pattern names (uses placeholders if not named)
        document.getElementById('btn-population-viewer').disabled = !canRun.population_viewer;

        // Evaluation buttons
        document.getElementById('btn-refresh-engineers').disabled = !status.data_collected;
        document.getElementById('engineer-select').disabled = !status.data_collected;
        document.getElementById('btn-score').disabled = !canRun.score_engineer || !currentEngineerId;

        // Auto-refresh engineers list if data was just collected
        if (status.data_collected && document.getElementById('engineer-select').options.length === 1) {
            refreshEngineers();
        }

    } catch (error) {
        console.error('Failed to update status:', error);
    }
}

async function batchScore() {
    const btn = document.getElementById('btn-batch-score');
    const statusEl = document.getElementById('batch-status');

    btn.disabled = true;
    showStatus(statusEl, 'Starting batch scoring and message assignment...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/batch_score`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Batch scoring failed');
        }

        showStatus(statusEl, 'Batch scoring started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            await updateStatus();
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'batch_scoring') {
                clearInterval(pollInterval);
                if (status.status.batch_scored) {
                    showStatus(statusEl, 'Batch scoring and message assignment complete!', 'success');
                } else if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                }
                btn.disabled = false;
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

async function refreshEngineers() {
    const select = document.getElementById('engineer-select');

    try {
        const response = await fetch(`${API_BASE}/api/engineers`);
        if (!response.ok) throw new Error('Failed to fetch engineers');

        const data = await response.json();

        // Clear and repopulate
        select.innerHTML = '<option value="">Select an engineer...</option>';
        data.engineers.forEach(engineer => {
            const option = document.createElement('option');
            option.value = engineer.engineer_id;
            option.textContent = engineer.engineer_id;
            select.appendChild(option);
        });

    } catch (error) {
        console.error('Failed to refresh engineers:', error);
    }
}

async function onEngineerSelected(event) {
    currentEngineerId = event.target.value;

    // Clear previous results
    document.getElementById('report-container').style.display = 'none';
    document.getElementById('scores-container').style.display = 'none';
    document.getElementById('eval-status').innerHTML = '';

    // Check if score file exists for this engineer
    await updateButtonStates();
}

async function updateButtonStates() {
    // Update general status
    await updateStatus();

    // If an engineer is selected, check if their score file exists
    if (currentEngineerId) {
        try {
            const response = await fetch(`${API_BASE}/api/check_score_exists?engineer_id=${currentEngineerId}`);
            const data = await response.json();

            // Generate Report button ONLY depends on individual score file existence
            const reportBtn = document.getElementById('btn-report');
            reportBtn.disabled = !data.exists;

            // View Report button depends on report file existence
            const viewReportBtn = document.getElementById('btn-view-report');
            viewReportBtn.disabled = !data.report_exists;

            // Download Report button depends on report file existence
            const downloadReportBtn = document.getElementById('btn-download-report');
            downloadReportBtn.disabled = !data.report_exists;

            // Score button needs batch scores to be available (for percentile calculations)
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());
            const scoreBtn = document.getElementById('btn-score');
            scoreBtn.disabled = !status.can_run.score_engineer;

        } catch (error) {
            console.error('Failed to check score existence:', error);
        }
    }
}

async function scoreEngineer() {
    if (!currentEngineerId) return;

    const btn = document.getElementById('btn-score');
    const statusEl = document.getElementById('eval-status');

    btn.disabled = true;
    showStatus(statusEl, 'Scoring engineer...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/score_engineer`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ engineer_id: currentEngineerId })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Scoring failed');
        }

        const scores = await response.json();

        // Display scores
        document.getElementById('scores-content').textContent = JSON.stringify(scores, null, 2);
        document.getElementById('scores-container').style.display = 'block';

        showStatus(statusEl, 'Scoring complete!', 'success');
        btn.disabled = false;

        // Update button states - Generate Report should now be enabled
        await updateButtonStates();

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

async function generateReport() {
    if (!currentEngineerId) return;

    const btn = document.getElementById('btn-report');
    const statusEl = document.getElementById('eval-status');

    btn.disabled = true;
    showStatus(statusEl, 'Generating report...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/generate_report`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ engineer_id: currentEngineerId })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Report generation failed');
        }

        const data = await response.json();

        // Display report
        document.getElementById('report-content').textContent = data.report;
        document.getElementById('report-container').style.display = 'block';

        showStatus(statusEl, 'Report generated!', 'success');

        // Update button states to enable View Report and Download Report buttons
        await updateButtonStates();

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

function viewReport() {
    // Get current engineer
    const engineerSelect = document.getElementById('engineer-select');
    const engineerId = engineerSelect.value;

    if (!engineerId) {
        alert('Please select an engineer first');
        return;
    }

    // Open report viewer in new tab (uses route, not static file)
    const viewerUrl = `report_viewer.html?engineer_id=${encodeURIComponent(engineerId)}`;
    window.open(viewerUrl, '_blank');
}

function openPopulationViewer() {
    // Open population viewer in new tab
    window.open('population_viewer.html', '_blank');
}

async function refreshLogs() {
    try {
        const response = await fetch(`${API_BASE}/api/logs`);
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        const logsContainer = document.getElementById('logs-container');
        logsContainer.innerHTML = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            lines.forEach(line => {
                if (line.startsWith('data:')) {
                    const logLine = line.substring(5).trim();
                    if (logLine && logLine !== 'No logs yet') {
                        appendLog(logLine);
                    }
                }
            });
        }

        // Auto-scroll to bottom
        logsContainer.scrollTop = logsContainer.scrollHeight;

    } catch (error) {
        console.error('Failed to fetch logs:', error);
    }
}

function appendLog(text) {
    const logsContainer = document.getElementById('logs-container');
    const logLine = document.createElement('div');
    logLine.className = 'log-line';

    // Add color based on log level
    if (text.includes('ERROR')) {
        logLine.classList.add('log-error');
    } else if (text.includes('WARNING')) {
        logLine.classList.add('log-warning');
    } else if (text.includes('INFO')) {
        logLine.classList.add('log-info');
    }

    logLine.textContent = text;
    logsContainer.appendChild(logLine);
}

function clearLogs() {
    document.getElementById('logs-container').innerHTML = '';
}

function downloadReport() {
    if (!currentEngineerId) return;

    const filename = `report_${currentEngineerId}.txt`;
    window.location.href = `${API_BASE}/api/download/reporting/${filename}`;
}

function showStatus(element, message, type) {
    element.textContent = message;
    element.className = `status-message ${type}`;
    element.style.display = 'block';
}

async function preprocessData() {
    const btn = document.getElementById('btn-preprocess');
    const statusEl = document.getElementById('preprocess-status');

    btn.disabled = true;
    showStatus(statusEl, 'Starting preprocessing...', 'info');

    try {
        // Get optional max activities override
        const maxActivitiesInput = document.getElementById('max-activities-per-engineer');
        const maxActivities = maxActivitiesInput.value ? parseInt(maxActivitiesInput.value) : null;

        // Build URL with query param if value provided
        let url = `${API_BASE}/api/preprocess`;
        if (maxActivities !== null) {
            url += `?max_activities_per_engineer=${maxActivities}`;
        }

        const response = await fetch(url, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Preprocessing failed');
        }

        showStatus(statusEl, 'Preprocessing started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            await updateStatus();
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'preprocessing') {
                clearInterval(pollInterval);
                showStatus(statusEl, 'Preprocessing complete!', 'success');
                btn.disabled = false;
            } else if (status.status.last_error) {
                clearInterval(pollInterval);
                showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                btn.disabled = false;
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

async function applyNormalization() {
    const btn = document.getElementById('btn-normalization');
    const statusEl = document.getElementById('preprocess-status');

    btn.disabled = true;
    showStatus(statusEl, 'Starting normalization...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/normalization`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Normalization failed');
        }

        showStatus(statusEl, 'Normalization started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            await updateStatus();
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'normalization') {
                clearInterval(pollInterval);
                if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                } else {
                    showStatus(statusEl, 'Normalization complete! Original files backed up with -base suffix.', 'success');
                }
                btn.disabled = false;
            }
        }, 2000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

async function trainVAE() {
    const btn = document.getElementById('btn-train-vae');
    const stopBtn = document.getElementById('btn-stop-training');
    const statusEl = document.getElementById('train-status');

    btn.disabled = true;
    stopBtn.style.display = 'inline-block';
    showStatus(statusEl, 'Starting VAE training (this may take 20+ minutes)...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/train_vae`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'VAE training failed');
        }

        showStatus(statusEl, 'VAE training started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            await updateStatus();
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'training_vae') {
                clearInterval(pollInterval);
                stopBtn.style.display = 'none';
                if (status.status.models_trained) {
                    showStatus(statusEl, 'VAE training complete!', 'success');
                } else if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                } else {
                    showStatus(statusEl, 'VAE training stopped.', 'info');
                }
                btn.disabled = false;
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
        stopBtn.style.display = 'none';
    }
}

function showExistingModelInput() {
    document.getElementById('existing-model-input').style.display = 'block';
    document.getElementById('btn-train-from-existing').disabled = true;
}

function hideExistingModelInput() {
    document.getElementById('existing-model-input').style.display = 'none';
    document.getElementById('btn-train-from-existing').disabled = false;
    document.getElementById('existing-model-path').value = '';
}

async function trainFromExistingVAE() {
    const modelPath = document.getElementById('existing-model-path').value.trim();
    if (!modelPath) {
        alert('Please enter the path to an existing VAE checkpoint');
        return;
    }

    const btn = document.getElementById('btn-start-from-existing');
    const stopBtn = document.getElementById('btn-stop-training');
    const statusEl = document.getElementById('train-status');

    btn.disabled = true;
    stopBtn.style.display = 'inline-block';
    hideExistingModelInput();
    showStatus(statusEl, `Starting VAE training from existing model: ${modelPath}...`, 'info');

    try {
        const response = await fetch(`${API_BASE}/api/train_vae_from_existing`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ model_path: modelPath })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'VAE training from existing model failed');
        }

        showStatus(statusEl, 'VAE training from existing model started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            await updateStatus();
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'training_vae_from_existing') {
                clearInterval(pollInterval);
                stopBtn.style.display = 'none';
                if (status.status.models_trained) {
                    showStatus(statusEl, 'VAE training from existing model complete!', 'success');
                } else if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                } else {
                    showStatus(statusEl, 'VAE training stopped.', 'info');
                }
                btn.disabled = false;
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
        stopBtn.style.display = 'none';
    }
}

async function stopTraining() {
    const stopBtn = document.getElementById('btn-stop-training');
    const statusEl = document.getElementById('train-status');

    stopBtn.disabled = true;
    stopBtn.textContent = 'Stopping...';

    try {
        const response = await fetch(`${API_BASE}/api/train/stop`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to stop training');
        }

        showStatus(statusEl, 'Stop requested. Training will stop after current epoch...', 'info');

    } catch (error) {
        showStatus(statusEl, `Error stopping: ${error.message}`, 'error');
        stopBtn.disabled = false;
        stopBtn.textContent = 'Stop Training';
    }
}

async function runSHAPAnalysis() {
    const btn = document.getElementById('btn-shap-analysis');
    const statusEl = document.getElementById('shap-status');

    btn.disabled = true;
    showStatus(statusEl, 'Starting SHAP analysis...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/shap_analysis`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'SHAP analysis failed');
        }

        showStatus(statusEl, 'SHAP analysis started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            await updateStatus();
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'shap_analysis') {
                clearInterval(pollInterval);
                if (status.status.patterns_interpreted) {
                    showStatus(statusEl, 'SHAP analysis complete!', 'success');
                } else if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                }
                btn.disabled = false;
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

async function identifyPatterns() {
    const btn = document.getElementById('btn-identify');
    const statusEl = document.getElementById('identify-status');

    btn.disabled = true;
    showStatus(statusEl, 'Starting pattern naming with LLM...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/identify_patterns`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Pattern naming failed');
        }

        showStatus(statusEl, 'Pattern naming started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            await updateStatus();
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'pattern_naming') {
                clearInterval(pollInterval);
                if (status.status.patterns_identified) {
                    showStatus(statusEl, 'Pattern naming complete!', 'success');
                } else if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                }
                btn.disabled = false;
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

// MongoDB and Engineer Management Functions

async function fetchMongoDB() {
    const btn = document.getElementById('btn-fetch-mongodb');
    const statusEl = document.getElementById('mongodb-status');

    const database = document.getElementById('mongodb-database').value.trim() || null;
    const maxEngineers = document.getElementById('mongodb-max-engineers').value || null;
    const maxActivities = document.getElementById('mongodb-max-activities').value || null;
    const append = document.getElementById('mongodb-append').checked;

    btn.disabled = true;
    showStatus(statusEl, `Fetching data from MongoDB (${database})...`, 'info');

    try {
        const requestBody = {
            database: database,
            append: append,
            max_engineers: maxEngineers ? parseInt(maxEngineers) : null,
            max_activities_per_engineer: maxActivities ? parseInt(maxActivities) : null
        };

        const response = await fetch(`${API_BASE}/api/fetch_mongodb`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'MongoDB fetch failed');
        }

        showStatus(statusEl, 'MongoDB fetch started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'fetching_mongodb') {
                clearInterval(pollInterval);
                if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                } else {
                    showStatus(statusEl, 'MongoDB fetch complete! Refresh summary to see engineers.', 'success');
                }
                btn.disabled = false;
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

function switchLoaderTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.loader-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === tabName);
    });

    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
        content.style.display = 'none';
        content.classList.remove('active');
    });

    const activeContent = document.getElementById(`tab-${tabName}`);
    if (activeContent) {
        activeContent.style.display = 'block';
        activeContent.classList.add('active');
    }
}

async function fetchNDJSON() {
    const btn = document.getElementById('btn-fetch-ndjson');
    const statusEl = document.getElementById('ndjson-status');

    const basePath = document.getElementById('ndjson-path').value.trim();
    const dateStart = document.getElementById('ndjson-date-start').value;
    const dateEnd = document.getElementById('ndjson-date-end').value;

    if (!basePath) {
        showStatus(statusEl, 'Please enter a path to the data folder', 'error');
        return;
    }

    btn.disabled = true;
    showStatus(statusEl, `Loading data from ${basePath}...`, 'info');

    try {
        const requestBody = {
            base_path: basePath
        };

        // Only include date_range if both dates are provided
        if (dateStart && dateEnd) {
            requestBody.date_range = {
                start: dateStart,
                end: dateEnd
            };
        }

        const response = await fetch(`${API_BASE}/api/fetch_ndjson`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'NDJSON fetch failed');
        }

        showStatus(statusEl, 'NDJSON loading started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'fetching_ndjson') {
                clearInterval(pollInterval);
                if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                } else {
                    showStatus(statusEl, 'NDJSON loading complete! Refresh summary to see engineers.', 'success');
                }
                btn.disabled = false;
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

async function refreshEngineerSummary() {
    const statusEl = document.getElementById('engineer-summary-status');
    const container = document.getElementById('engineer-summary-container');

    showStatus(statusEl, 'Loading engineer summary...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/engineers`);

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to fetch engineer summary');
        }

        const data = await response.json();

        // Update counts
        document.getElementById('train-count').textContent = data.train_count;
        document.getElementById('validation-count').textContent = data.validation_count;
        document.getElementById('bot-count').textContent = data.bot_count;
        document.getElementById('total-engineers').textContent = data.total_engineers;

        // Store data for sorting
        engineerSummaryData = data.engineers;

        // Sort and render
        sortEngineerTable(currentSortColumn, false);

        container.style.display = 'block';
        statusEl.style.display = 'none';

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
    }
}

function sortEngineerTable(column, toggleDirection = true) {
    // Toggle direction if clicking the same column
    if (toggleDirection) {
        if (column === currentSortColumn) {
            currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            currentSortColumn = column;
            // Default direction based on column type
            currentSortDirection = (column === 'activity_count' || column === 'is_bot' || column === 'is_internal') ? 'desc' : 'asc';
        }
    }

    // Sort the data
    engineerSummaryData.sort((a, b) => {
        let aVal, bVal;

        switch (column) {
            case 'engineer_id':
                aVal = a.engineer_id.toLowerCase();
                bVal = b.engineer_id.toLowerCase();
                break;
            case 'activity_count':
                aVal = a.activity_count;
                bVal = b.activity_count;
                break;
            case 'split':
                aVal = a.split;
                bVal = b.split;
                break;
            case 'sources':
                aVal = a.sources.join(', ').toLowerCase();
                bVal = b.sources.join(', ').toLowerCase();
                break;
            case 'is_bot':
                aVal = a.is_bot ? 1 : 0;
                bVal = b.is_bot ? 1 : 0;
                break;
            case 'is_internal':
                aVal = a.is_internal ? 1 : 0;
                bVal = b.is_internal ? 1 : 0;
                break;
            case 'projects':
                aVal = (a.projects || '').toLowerCase();
                bVal = (b.projects || '').toLowerCase();
                break;
            default:
                return 0;
        }

        if (aVal < bVal) return currentSortDirection === 'asc' ? -1 : 1;
        if (aVal > bVal) return currentSortDirection === 'asc' ? 1 : -1;
        return 0;
    });

    renderEngineerTable();
    updateSortIndicators();
}

function renderEngineerTable() {
    const tbody = document.getElementById('engineer-summary-body');
    tbody.innerHTML = '';

    engineerSummaryData.forEach(eng => {
        const row = document.createElement('tr');
        const botIcon = eng.is_bot ? '<span title="Bot" style="font-size: 1.2em;">&#129302;</span>' : '<span title="Human" style="color: #888;">&#128100;</span>';
        const internalIcon = eng.is_internal === undefined ? '<span style="color: #888;">-</span>' :
            (eng.is_internal ? '<span title="Internal" style="color: #28a745;">&#10004;</span>' : '<span title="External" style="color: #dc3545;">&#10006;</span>');
        const projectBadges = (eng.projects || '').split(',')
            .filter(p => p)
            .map(p => `<span style="display: inline-block; padding: 2px 6px; margin: 1px; background: #e0e0e0; border-radius: 4px; font-size: 0.8em;">${p}</span>`)
            .join('');

        row.innerHTML = `
            <td style="padding: 8px; border-bottom: 1px solid #eee;">
                <input type="checkbox" class="engineer-checkbox" value="${eng.engineer_id}">
            </td>
            <td style="padding: 8px; border-bottom: 1px solid #eee;">${eng.engineer_id}</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee;">${eng.activity_count}</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee;">
                <span style="color: ${eng.split === 'train' ? '#28a745' : '#007bff'};">${eng.split}</span>
            </td>
            <td style="padding: 8px; border-bottom: 1px solid #eee;">${eng.sources.join(', ')}</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${botIcon}</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${internalIcon}</td>
            <td style="padding: 8px; border-bottom: 1px solid #eee;">${projectBadges}</td>
        `;
        tbody.appendChild(row);
    });

    // Add change listeners to checkboxes
    document.querySelectorAll('.engineer-checkbox').forEach(cb => {
        cb.addEventListener('change', updateActionButtons);
    });
}

function updateSortIndicators() {
    // Clear all indicators
    ['engineer_id', 'activity_count', 'split', 'sources', 'is_bot', 'is_internal', 'projects'].forEach(col => {
        const indicator = document.getElementById(`sort-indicator-${col}`);
        if (indicator) {
            indicator.textContent = '';
        }
    });

    // Set current indicator
    const currentIndicator = document.getElementById(`sort-indicator-${currentSortColumn}`);
    if (currentIndicator) {
        currentIndicator.textContent = currentSortDirection === 'asc' ? '' : '';
    }
}

function toggleSelectAllEngineers(event) {
    const checked = event.target.checked;
    document.querySelectorAll('.engineer-checkbox').forEach(cb => {
        cb.checked = checked;
    });
    updateActionButtons();
}

function updateActionButtons() {
    const selectedCount = document.querySelectorAll('.engineer-checkbox:checked').length;
    const hasSelection = selectedCount > 0;

    document.getElementById('btn-set-train').disabled = !hasSelection;
    document.getElementById('btn-set-validation').disabled = !hasSelection;
    document.getElementById('btn-remove-selected').disabled = !hasSelection;
    document.getElementById('btn-merge-engineers').disabled = !hasSelection;
}

function getSelectedEngineerIds() {
    const checkboxes = document.querySelectorAll('.engineer-checkbox:checked');
    return Array.from(checkboxes).map(cb => cb.value);
}

async function setEngineerSplit(split) {
    const engineerIds = getSelectedEngineerIds();
    if (engineerIds.length === 0) return;

    const statusEl = document.getElementById('action-status');

    try {
        const response = await fetch(`${API_BASE}/api/engineers/set_split`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ engineer_ids: engineerIds, split: split })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || `Failed to set split to ${split}`);
        }

        const data = await response.json();
        showStatus(statusEl, `${data.message} (${data.rows_updated} rows)`, 'success');

        // Refresh the summary
        await refreshEngineerSummary();

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
    }
}

async function removeSelectedEngineers() {
    const engineerIds = getSelectedEngineerIds();
    if (engineerIds.length === 0) return;

    const confirmed = confirm(`Are you sure you want to remove ${engineerIds.length} engineer(s)?\n\nThis will delete all their activities from the CSV.`);
    if (!confirmed) return;

    const statusEl = document.getElementById('action-status');

    try {
        const response = await fetch(`${API_BASE}/api/engineers/remove`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ engineer_ids: engineerIds })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to remove engineers');
        }

        const data = await response.json();
        showStatus(statusEl, `${data.message} (${data.rows_deleted} rows)`, 'success');

        // Refresh the summary
        await refreshEngineerSummary();

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
    }
}

async function mergeSelectedEngineers() {
    const sourceIds = getSelectedEngineerIds();
    if (sourceIds.length === 0) return;

    const targetId = document.getElementById('merge-target-id').value.trim();
    if (!targetId) {
        alert('Please enter a target ID to merge into');
        return;
    }

    const confirmed = confirm(`Merge ${sourceIds.length} engineer(s) into "${targetId}"?\n\nSelected IDs: ${sourceIds.join(', ')}`);
    if (!confirmed) return;

    const statusEl = document.getElementById('action-status');

    try {
        const response = await fetch(`${API_BASE}/api/engineers/merge`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ source_ids: sourceIds, target_id: targetId })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to merge engineers');
        }

        const data = await response.json();
        showStatus(statusEl, `${data.message} (${data.rows_updated} rows)`, 'success');

        // Clear the target input
        document.getElementById('merge-target-id').value = '';

        // Refresh the summary
        await refreshEngineerSummary();

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
    }
}

// Synthetic Profile Functions

async function generateSyntheticProfiles() {
    const btn = document.getElementById('btn-generate-synthetic');
    const statusEl = document.getElementById('synthetic-status');

    const copiesPerProfile = parseInt(document.getElementById('synthetic-copies').value) || 3;

    btn.disabled = true;
    showStatus(statusEl, 'Starting synthetic profile generation...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/synthetic/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ copies_per_profile: copiesPerProfile })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Synthetic generation failed');
        }

        showStatus(statusEl, 'Synthetic generation started. Check logs for progress.', 'info');

        const pollInterval = setInterval(async () => {
            const status = await fetch(`${API_BASE}/api/status`).then(r => r.json());

            if (status.status.current_task !== 'generating_synthetic') {
                clearInterval(pollInterval);
                if (status.status.last_error) {
                    showStatus(statusEl, `Error: ${status.status.last_error}`, 'error');
                } else {
                    showStatus(statusEl, 'Synthetic generation complete! Refresh summary to see profiles.', 'success');
                    await refreshSyntheticSummary();
                }
                btn.disabled = false;
            } else {
                const progress = status.status.synthetic_generation_progress || 0;
                const total = status.status.synthetic_generation_total || 0;
                if (total > 0) {
                    showStatus(statusEl, `Generating... ${progress}/${total} profiles`, 'info');
                }
            }
        }, 3000);

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
        btn.disabled = false;
    }
}

async function refreshSyntheticSummary() {
    const statusEl = document.getElementById('synthetic-status');
    const container = document.getElementById('synthetic-summary-container');
    const addBtn = document.getElementById('btn-add-synthetic');

    showStatus(statusEl, 'Loading synthetic profile summary...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/synthetic/summary`);

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to fetch synthetic summary');
        }

        const data = await response.json();

        // Update counts
        document.getElementById('synthetic-template-count').textContent = data.template_count;
        document.getElementById('synthetic-profile-count').textContent = data.total_profiles;

        // Update details
        const detailsEl = document.getElementById('synthetic-details');
        if (data.profile_details.length > 0) {
            detailsEl.innerHTML = data.profile_details.map(d =>
                `<div><strong>${d.template_name}:</strong> ${d.profile_count} profiles</div>`
            ).join('');
            addBtn.disabled = false;
        } else {
            detailsEl.innerHTML = '<div style="color: #666;">No synthetic profiles generated yet.</div>';
            addBtn.disabled = true;
        }

        container.style.display = 'block';
        statusEl.style.display = 'none';

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
    }
}

async function addSyntheticToActivities() {
    const btn = document.getElementById('btn-add-synthetic');
    const statusEl = document.getElementById('synthetic-status');
    const split = document.getElementById('synthetic-split').value;

    const confirmed = confirm(`Add all synthetic profiles to activities.csv as "${split}" data?\n\nThis will convert JSON profiles to CSV rows and merge them with existing activities.`);
    if (!confirmed) return;

    btn.disabled = true;
    showStatus(statusEl, 'Adding synthetic profiles to activities...', 'info');

    try {
        const response = await fetch(`${API_BASE}/api/synthetic/add_to_activities`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ split: split })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to add synthetic profiles');
        }

        const data = await response.json();

        let message = `Added ${data.profiles_added} profiles (${data.activities_added} activities)`;
        if (data.errors && data.errors.length > 0) {
            message += ` with ${data.errors.length} errors`;
        }

        showStatus(statusEl, message, 'success');

        // Refresh engineer summary to show new engineers
        await refreshEngineerSummary();

    } catch (error) {
        showStatus(statusEl, `Error: ${error.message}`, 'error');
    } finally {
        btn.disabled = false;
    }
}
    </script>
</body>
</html>
